/**
*
* Halftone
* @package FILTER.js
*
**/
!function(FILTER, undef) {
"use strict";

var f1 = 7/16, f2 = 3/16, f3 = 5/16, f4 = 1/16,
    MODE = FILTER.MODE, A32F = FILTER.Array32F, clamp = FILTER.Color.clamp,
    intensity = FILTER.Color.intensity;

// http://en.wikipedia.org/wiki/Halftone
// http://en.wikipedia.org/wiki/Error_diffusion
// http://www.visgraf.impa.br/Courses/ip00/proj/Dithering1/average_dithering.html
// http://en.wikipedia.org/wiki/Floyd%E2%80%93Steinberg_dithering
FILTER.Create({
    name: "HalftoneFilter"

    // parameters
    ,size: 1
    ,thresh: 0.4
    ,mode: MODE.GRAY
    //,inverse: false

    // this is the filter constructor
    ,init: function(size, threshold, mode/*, inverse*/) {
        var self = this;
        self.size = size || 1;
        self.thresh = clamp(null == threshold ? 0.4 : threshold,0,1);
        self.mode = mode || MODE.GRAY;
        //self.inverse = !!inverse
    }

    // support worker serialize/unserialize interface
    ,path: FILTER.Path

    ,threshold: function(t) {
        this.thresh = clamp(t, 0, 1);
        return this;
    }

    /*,invert: function(bool) {
        if (!arguments.length) bool = true;
        this.inverse = !!bool;
        return this;
    }*/

    ,serialize: function() {
        var self = this;
        return {
             size: self.size
            ,thresh: self.thresh
            //,inverse: self.inverse
        };
    }

    ,unserialize: function(params) {
        var self = this;
        self.size = params.size;
        self.thresh = params.thresh;
        //self.inverse = params.inverse;
        return self;
    }

    // this is the filter actual apply method routine
    ,apply: function(im, w, h) {
        var self = this, l = im.length, imSize = l>>>2,
            err = new A32F(imSize*3), pixel, index, t, rgb, ycbcr,
            size = self.size, area = size*size, invarea = 1.0/area,
            threshold = 255*self.thresh, size2 = size2<<1,
            colored = MODE.RGB === self.mode, x, y, yw, sw = size*w, i, j, jw,
            sum_r, sum_g, sum_b, r, g, b, qr, qg, qb, qrf, qgf, qbf
            //,inverse = self.inverse,one = inverse?0:255, zero = inverse?255:0
            ,f11 = /*area**/f1, f22 = /*area**/f2
            ,f33 = /*area**/f3, f44 = /*area**/f4
        ;

        for (y=0,yw=0,x=0; y<h;)
        {
            sum_r = sum_g = sum_b = 0;
            if (colored)
            {
                for (i=0,j=0,jw=0; j<size;)
                {
                    pixel = (x+yw+i+jw)<<2; index = (x+yw+i+jw)*3;
                    sum_r += im[pixel  ] + err[index  ];
                    sum_g += im[pixel+1] + err[index+1];
                    sum_b += im[pixel+2] + err[index+2];
                    if (++i >= size) {i=0; ++j; jw+=w;}
                }
                sum_r *= invarea; sum_g *= invarea; sum_b *= invarea;
                t = intensity(sum_r, sum_g, sum_b);
                if (t > threshold)
                {
                    r = sum_r|0; g = sum_g|0; b = sum_b|0;
                }
                else
                {
                    r = 0; g = 0; b = 0;
                }
            }
            else
            {
                for (i=0,j=0,jw=0; j<size;)
                {
                    pixel = (x+yw+i+jw)<<2; index = (x+yw+i+jw)*3;
                    sum_r += im[pixel  ] + err[index  ];
                    if (++i >= size) {i=0; ++j; jw+=w;}
                }
                t = sum_r * invarea;
                if (t > threshold)
                {
                    r = 255; g = 255; b = 255;
                }
                else
                {
                    r = 0; g = 0; b = 0;
                }
            }

            pixel = (x+yw)<<2;
            qr = im[pixel  ] - r;
            qg = im[pixel+1] - g;
            qb = im[pixel+2] - b;

            if (x+size < w)
            {
                qrf = f11*qr; qgf = f11*qg; qbf = f11*qb;
                for (i=size,j=0,jw=0; j<size;)
                {
                    index = (x+yw+i+jw)*3;
                    err[index  ] += qrf;
                    err[index+1] += qgf;
                    err[index+2] += qbf;
                    if (++i >= size2) {i=size; ++j; jw+=w;}
                }
            }
            if (y+size < h && x > size)
            {
                qrf = f22*qr; qgf = f22*qg; qbf = f22*qb;
                for (i=-size,j=size,jw=0; j<size2;)
                {
                    index = (x+yw+i+jw)*3;
                    err[index  ] += qrf;
                    err[index+1] += qgf;
                    err[index+2] += qbf;
                    if (++i >= 0) {i=-size; ++j; jw+=w;}
                }
            }
            if (y+size < h)
            {
                qrf = f33*qr; qgf = f33*qg; qbf = f33*qb;
                for (i=0,j=size,jw=0; j<size2;)
                {
                    index = (x+yw+i+jw)*3;
                    err[index  ] += qrf;
                    err[index+1] += qgf;
                    err[index+2] += qbf;
                    if (++i >= size) {i=0; ++j; jw+=w;}
                }
            }
            if (y+size < h && x+size < w)
            {
                qrf = f44*qr; qgf = f44*qg; qbf = f44*qb;
                for (i=size,j=size,jw=0; j<size2;)
                {
                    index = (x+yw+i+jw)*3;
                    err[index  ] += qrf;
                    err[index+1] += qgf;
                    err[index+2] += qbf;
                    if (++i >= size2) {i=size; ++j; jw+=w;}
                }
            }

            for (i=0,j=0,jw=0; j<size;)
            {
                pixel = (x+yw+i+jw)<<2;
                im[pixel  ] = r;
                im[pixel+1] = g;
                im[pixel+2] = b;
                if (++i >= size) {i=0; ++j; jw+=w;}
            }

            x+=size; if (x >= w) {x=0; y+=size; yw+=sw;}
        }
        return im;
    }
});

}(FILTER);